// utils/craftjsUtils.ts
import { NodeData } from '@craftjs/core'; // Node type might not be needed directly here

// Define a type for the structure Craft.js often uses
// Adjust based on your specific SerializedData structure if needed
type CraftNodeMap = Record<string, NodeData>;

/**
 * Simple regex-based HTML tag stripper.
 * Note: This is basic and might not handle all edge cases perfectly,
 * but it's often sufficient for extracting text from simple HTML generated by editors.
 * For more robust stripping, consider a dedicated library like 'striptags' or 'sanitize-html'.
 * @param htmlString The HTML string to strip tags from.
 * @returns Plain text content.
 */
function stripHtmlTags(htmlString: string): string {
    if (!htmlString) return '';
    // Remove tags, replace multiple spaces/newlines with single space, trim
    return htmlString
           .replace(/<[^>]*>/g, ' ') // Replace tags with space
           .replace(/\\n/g, ' ')      // Replace escaped newlines
           .replace(/\s{2,}/g, ' ') // Replace multiple whitespace chars with single space
           .trim();
}

/**
 * Recursively extracts text content from Craft.js nodes, stripping HTML tags.
 * @param nodeId The ID of the current node to process.
 * @param nodes The map of all nodes in the Craft.js state.
 * @param extractedText Accumulated text (used internally for recursion).
 * @returns A string containing concatenated plain text content.
 */
function extractTextFromNode(nodeId: string, nodes: CraftNodeMap, extractedText: string = ''): string {
    const node = nodes[nodeId];
    if (!node) return extractedText;

    let currentText = extractedText;

    // --- Text Extraction Logic (Now with HTML Stripping) ---
    if (node.props?.text && typeof node.props.text === 'string') {
        // Handle nodes with a direct 'text' prop
        currentText += stripHtmlTags(node.props.text) + ' ';
    } else if (node.props?.content && typeof node.props.content === 'string') {
        // Handle nodes with a 'content' prop (like the example Text node)
        currentText += stripHtmlTags(node.props.content) + ' ';
    } else if (node.displayName === 'Text' && typeof node.props?.children === 'string') {
         // Handle cases where text might be in children as a simple string
         currentText += stripHtmlTags(node.props.children) + ' ';
    }
    // Add more 'else if' conditions for your specific custom components
    // e.g., else if (node.type.resolvedName === 'CustomParagraph' && typeof node.props.paragraphText === 'string') {
    //     currentText += stripHtmlTags(node.props.paragraphText) + ' ';
    // }

    // Recursively process child nodes
    if (node.nodes && node.nodes.length > 0) {
        node.nodes.forEach(childId => {
            currentText = extractTextFromNode(childId, nodes, currentText);
        });
    }
    // Note: Recursively processing children passed via props can be complex
    // and depends heavily on how your components are structured. Usually,
    // structural children are in the `nodes` array.

    // Clean up extra spaces only at the very end (in the calling function)
    return currentText;
}

/**
 * Extracts meaningful plain text content from potentially double-serialized Craft.js data.
 * @param serializedData The stringified JSON from Craft.js state (might be double-serialized).
 * @returns The extracted plain text content or an empty string if input is invalid or no text is found.
 */
export function extractTextFromCraftData(serializedData: string | undefined): string {
    if (!serializedData) {
        console.warn('extractTextFromCraftData received undefined input.');
        return '';
    }
    try {
        let parsedData: CraftNodeMap;
        try {
             // Attempt 1: Assume it might be double-serialized JSON ("\"JSON_STRING\"")
             const intermediateJsonString = JSON.parse(serializedData);
             if (typeof intermediateJsonString === 'string') {
                 // It was double-serialized, parse the inner string
                 parsedData = JSON.parse(intermediateJsonString);
             } else if (typeof intermediateJsonString === 'object' && intermediateJsonString !== null) {
                 // It might have been single-serialized JSON ("JSON_STRING")
                 parsedData = intermediateJsonString as CraftNodeMap; // Assume it's the correct type
             } else {
                 console.warn('Parsed Craft.js data is neither a string nor an object:', intermediateJsonString);
                 return '';
             }
        } catch(e) {
             // If the first parse fails, maybe it's *not* valid JSON at all, or just single-serialized
             // Let's try parsing the original input directly as a fallback
             console.warn('Initial parse failed, attempting direct parse. Original error:', (e as Error).message);
             parsedData = JSON.parse(serializedData);
        }


        if (!parsedData || typeof parsedData !== 'object' || !parsedData.ROOT) {
            console.warn('Invalid Craft.js data structure: ROOT node not found or data is not an object.');
            console.debug('Parsed Data:', parsedData); // Log the problematic data
            return '';
        }

        const rawExtractedText = extractTextFromNode('ROOT', parsedData);

        // Final cleanup of whitespace
        const cleanedText = rawExtractedText.replace(/\s+/g, ' ').trim();

        if (!cleanedText) {
             console.warn('extractTextFromCraftData: No text content found after processing nodes.');
        } else {
             console.log('extractTextFromCraftData: Successfully extracted text.'); // Success log
             // console.debug('Extracted Text:', cleanedText); // Optional: Log extracted text for debugging
        }

        return cleanedText;

    } catch (error) {
        console.error('Error parsing or processing Craft.js data:', error);
        console.error('Problematic serializedData input:', serializedData); // Log the input that failed
        return '';
    }
}